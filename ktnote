1、变量、常量、函数
2、条件操作符

// 变量
var a = 1
var b: Boolean = false
var c: Float = a.toFloat()// 不支持自动转型
var sb = StringBuilder()

// 变量要求立即赋值，没有默认值概念。若未立即赋值，使用lateinit
lateinit var d: Int
d = 1


// 常量（出于安全考虑，推荐使用常量）
val a = 1

// 常量同样要求立即赋值。若未立即赋值，使用by lazy {}表达式
val b:String by lazy { "常量" }


// == 和 ===
// 对应Java的 equals() 和 ==
    val str1 = String()
    val str2 = String()
    println(str1 == str2)// true
    println(str1 === str2)// false


// 无返回值函数
fun welcome(name: String) {
    print("你好，${name}先生")// 字符串模板
}

// 有返回值函数
fun plus(a: Int, b: Int): Int {
    return a + b
}
fun plus(a: Int, b: Int): Int = a + b// 函数表达式


// if
fun max(a: Int, b: Int): Int = if (a > b) a else b// 三目运算表达式

if (a and b) {
    // a & b
}

if (a or b) {
    // a | b
}

if (a.not()) {
    // !a
}

if (a in list) {// in关键字
}

if (a in 1..10) {
    // a在[1, 10]范围内
}

if (a in 1 until 10) {
    // a在[1, 10)范围内
}

if (a in 10 downto 1) {
    // 降序，a在[10, 1]范围内
}

fun f(obj: Any) {// Any相当于Java的Object
    if (obj is StringBuilder) {// is关键字，判断类型
        obj.append("hello")// 如果选择表达式中条件满足，则自动转型
    } else {
        (obj as StringBuffer).append("hello")// as关键字，强转
    }
}

// when条件表达式，支持任意数据类型
when (obj) {
    true -> {}
    1, 2 -> {}
    in list -> {}
    is String -> {}
    getMyId() -> {}
    null -> {}
    else -> {}
}


// for
for (i in 1..10 step 2) {// i+=2
    // 1, 3, 5, 7, 9
}

for (name in names) {// 遍历元素
}

for (i in names.indices) {// 遍历下角标index
}

for ((i, name) in names.withIndex()) {// 遍历下角标和元素
}

for ((key, value) in map) {// 遍历Map集合
}

list.forEach {
    print(it)// 当表达式只有一个参数时，可使用关键字"it"表示
}


// while、do/while循环与Java无异


// 数组、集合
val array = arrayOf(1, 2, 3)
val a = array[0]

val list = listOf("a", "b", "c")
val a = list[0]

val set = setOf<Int>(1, 2, 3)

var map = mapOf<String, String>("account" to "admin", "password" to "123456")
map["password"] = "abcdef"

// 可变参数
fun f(count: Int, vararg values: Float) {
    ObjectAnimator.ofFloat(Button(this), "alpha", *values)
}


// 空安全
var list : List<String>? = null

list!!.size()// 断言，我们认为它不为空，万一为空则抛出NPE
list?.size()// 空安全，返回null，不会抛出异常
list?.size() ?: 0// ?: Elvis操作符：如果不为空，正常操作，如果为空则返回默认值


// 面向对象

// 可见性
// public，默认，整个工程可访问
// internal，所在module可访问
// protected，子类可访问
// private，仅当前类可访问


// 类
class Animal

// 主构造方法（Primary Constructor）及其方法体
class Animal(name: String) {
    private lateinit var name: String

        init {
            this.name = name
        }
}

// 主构造方法传入全局参数
class Animal(var name: String)

// 主构造方法使用修饰符时，不能省略constructor
class Animal private constructor()


// 多构造方法一：一主多从，从构造方法必须代理主构造方法
class MyDialog() {
    init {
        println("initWindow")
    }

    constructor(layoutId: Int) : this() {
        println("setContentView(${layoutId})")
    }
}
val dialog = MyDialog(layout)
打印日志如下
initWindow
setContentView(layout)


// 多构造方法二：无主多从（Secondary Constructor）
class MyDialog {
    constructor() {
        this(layout)
    }

    constructor(layoutId: Int) {
        println("setContentView(${layoutId})")
    }
}
val dialog = MyDialog()
打印日志如下
setContentView(layout)

// 方法参数默认值实现方法重载的效果
class MyDialog {
    constructor(layoutId: Int = layout) {
        println("setContentView(${layoutId})")
    }
}
val dialog = MyDialog()
打印日志如下
setContentView(layout)


// 成员变量，默认自带getter和setter，变量可自定义getter和setter，常量只能自定义getter
// field关键字，代表当前成员变量，注意：只能在自定义getter和setter中使用
class Animal {

    var age: Int = 0

    var name: String = ""
        get() = field
        set(value) {
            field = value
        }
}

val animal = Animal()
animal.name = "旺财"// setter
val name = animal.name// getter


// 继承一：重写一个父类构造方法
// 默认等效于Java的final，使用open修饰符后，类可被继承，方法可被重写，成员变量的getter和setter可被重写
open class ViewHolder(itemView: View) {
     open fun bind()
 }

class MyViewHolder(itemView : View): ViewHolder(itemView) {

    override fun bind()
}

// 继承二：重写多个父类构造方法
class MyView : View {
    constructor(context: Context?) : super(context)
    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs)
}


// 数据模型类JavaBean（也可称作POJO类）
// 1、构造方法中至少有一个属性，且必须有var或val修饰（自带getter和setter）
// 2、自动重写equals()、hashCode()、toString()三个方法
data class Animal(var name: String? = null, var age: Int = 0)


// 伴生对象companion object，内部的属性/方法相当于在Java中用static修饰
class MyFragment: Fragment() {
    companion object {
        const val TAG = "MyFragment"// const关键字，只能在伴生对象中使用，相当于Java的public static final String TAG

        fun newInstance(): MyFragment = MyFragment()
    }
}
val tag = MyFragment.TAG
val fragment = MyFragment.newInstance()


// 伴生对象object
object User {
    fun login() {
    }
}
User.login()

// 伴生对象kt在java的调用：【伴】随类诞【生】的【对象】，且仅有一个，即单例
MyFragment fragment = MyFragment.Companion.newInstance();
User.INSTANCE.login();



// abstract关键字与Java无异

// 实现Interface接口。
class MyActivity : Activity(), OnClickListener, OnClickListener {
    override fun onClick(v: View?) {
    }
    override fun onLongClick(v: View?) {
    }
}


// 内部类
class Outer {
    inner class Inner// inner关键字，内部类持有外部类的引用
}

// 静态内部类
class Outer {
    class Inner// 内部类不会持有外部类的引用，相当于Java的static class Inner {}
}


// 匿名内部类（对象表达式）
Button(context).setOnClickListener(object : View.OnClickListener {
    override fun onClick(v: View) {
        println(v.id)
    }
})

Thread(object : Runnable {
    override fun run() {
        // TODO
    }
}).start()


// Lambda表达式
Button(context).setOnClickListener { println(it.id) }

thread { // TODO }


class ImageLoader(context: Context, callback: (String, ImageView) -> Unit)

// ImageLoader(context, { path, v -> Glide.with(v).load(path).into(v) })// Lambda表达式
ImageLoader(context) { path, v -> Glide.with(v).load(path).into(v) }// 闭包表达式，推荐写法


// 反射
MainActivity::class// Kotlin的KClass类型
MainActivity::class.java// Java的Class类型
context.startActivity(Intent(context, MainActivity::class.java))// Intent(Context, Class)
